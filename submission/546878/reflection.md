Working on the Proof of Existence smart contract was my first hands-on experience with designing, deploying, and testing a Solidity application on Ethereum. At the beginning, I struggled to connect the theoretical concepts of blockchains with the practical steps of coding, but through trial and error in Remix I started to understand how mappings, events, and functions interact inside a contract.
One of the biggest challenges was figuring out how require() works and why it is essential to protect the contract state from invalid transactions. I also learned the difference between returning raw values, like timestamps, and returning booleans for verification. These small details taught me that clarity in contract design is just as important as functionality, especially when others may rely on the contract.
Deploying on Sepolia was another valuable step, because it forced me to think about gas, addresses, and verified contract sources on Etherscan. I also realized the importance of documenting and providing evidence of each stageâ€”screenshots, deployment details, and reflection, so that others can trace the work.
Overall, the project gave me confidence in using Solidity and GitHub workflows, such as committing changes and creating pull requests. I now appreciate how blockchain development requires both technical precision and careful organization, and I feel better prepared for more advanced smart contract projects.
